# Using Streams
---------------
A Stream in Java is a sequence of data. A Stream pipeline consists of the operations that run on a stream to 
produce a result. First, we look at the flow of pipelines conceptually. After that, we get into the code.

## I. Understanding the Pipeline Flow
Think of a stream pipeline as an assembly line in a factory. Suppose that we are running an assembly line to make signs 
for the animal exhibits at the zoo. We have a number of jobs. It is one person’s job to take the signs out of a box. 
It is a second person’s job to paint the sign. It is a third person’s job to stencil the name of the animal on the 
sign. It’s the last person’s job to put the completed sign in a box to be carried to the proper exhibit.

&emsp;&emsp;
Notice that the second person can’t do anything until one sign has been taken out of the box by the first person. 
Similarly, the third person can’t do anything until one sign has been painted, and the last person can’t do anything 
until it is stenciled.

&emsp;&emsp;
The assembly line for making signs is finite. Once we process the contents of our box of signs, we are finished. Finite 
streams have a limit. Other assembly lines essentially run forever, like one for food production. Of course, they do 
stop at some point when the factory closes down, but pretend that doesn't happen. Or think of sunrise/sunset cycle as 
infinite, since it doesn't end for an inordinately large period of time.

&emsp;&emsp;
Another important feature of an assembly line is that each person touches each element to do their operation, and then 
that piece of data is gone. It doesn't come back. The next person deals with it at that point. This is different than 
the lists and queues that you saw in the previous chapter. With a list, you can access any element at any time. With a 
queue, you are limited in which elements you can access, but all of the elements are there. With streams, the data 
isn’t generated up front—it is created when needed. This is an example of lazy evaluation, which delays execution 
until necessary.

&emsp;&emsp;
Many things can happen in the assembly line stations along the way. In functional programming, these are called stream 
operations. Just like with the assembly line, operations occur in a pipeline. Someone has to start and end the work, 
and there can be any number of stations in between. After all, a job with one person isn’t an assembly line! 

There are three parts to a stream pipeline, as shown in Figure 10.2.
- __Source__: Where the stream comes from
- __Intermediate operations__: Transforms the stream into another one. There can be as few or as many intermediate
operations as you'd like. Since streams use lazy evaluation, the intermediate operations do not run until the 
terminal operation runs.
- __Terminal operation__: Produces a result. Since streams can be used only once, the stream is no longer valid after 
a terminal operation completes.

> __Figure 10.2__ Stream pipeline
> ```java
> Source -> Intermediate Operations -> Terminal Operation
>                1 -> 2 -> ... -> n
> ```

&emsp;&emsp;
Notice that the operations are unknown to us. When viewing the assembly line from the outside, you care only about 
what comes in and goes out. What happens in between is an implementation detail.

&emsp;&emsp;
You will need to know the differences between intermediate and terminal operations well. Make sure you can fill in
Table 10.2.
> __Table 10.2__ Intermediate vs. Terminal operations
>
| Scenario                              | Intermediate operation | Terminal Operation |
|:--------------------------------------|:-----------------------|:-------------------|
 | Required part of useful pipeline?     | No                     | Yes                |
| Can exist multiple times in pipeline? | Yes                    | No                 |
| Return type is stream type?           | Yes                    | No                 |
| Executed upon method call?            | No                     | Yes                |
| Stream valid after call?              | Yes                    | No                 |
>
>
&emsp;&emsp;
A factory typically has a foreperson(capataz) who oversees the work. Java serves as the foreperson when working with 
stream pipelines. This is a really important role, especially when dealing with lazy evaluation and infinite streams. 
Think of declaring the stream as giving instructions to the foreperson. As the foreperson finds out what needs to be 
done, they set up the stations and tell the workers what their duties will be. However, the workers do not start until 
the foreperson tells them to begin. The foreperson waits until they see the terminal operation to kick off the work. 
They also watch the work and stop the line as soon as work is complete.

&emsp;&emsp;
Let’s look at a few examples of this. We aren’t using code in these examples because it is really important to 
understand the stream pipeline concept before starting to write the code. Figure 10.3 shows a stream pipeline with 
one intermediate operation.
> __Figure 10.3__ Steps in running a stream pipeline
> ```java
> Take sign out of box        ->      Intermediate Operation      -> Put sign in pile
>                                        (paint sign)
>                                        1 -> 2 -> 3
>                                        4 -> 5 -> 6
> ```
>

&emsp;&emsp;
Let’s take a look at what happens from the point of view of the foreperson. First, they see that the source is taking 
signs out of the box. The foreperson sets up a worker at the table to unpack the box and says to await a signal to 
start. Then the foreperson sees the intermediate operation to paint the sign. They set up a worker with paint and say 
to await a signal to start. Finally, the foreperson sees the terminal operation to put the signs into a pile. They 
set up a worker to do this and yell that all three workers should start.

&emsp;&emsp;
Suppose that there are two signs in the box. Step 1 is the first worker taking one sign out of the box and handing it 
to the second worker. Step 2 is the second worker painting it and handing it to the third worker. Step 3 is the third 
worker putting it in the pile. Steps 4–6 are this same process for the other sign. Then the foreperson sees that there 
are no signs left and shuts down the entire enterprise.

&emsp;&emsp;
The foreperson is smart and can make decisions about how to best do the work based on what is needed. As an example, 
let’s explore the stream pipeline in Figure 10.4.
> __Figure 10.4__ A Stream pipeline with a limit
> ```java
> Take sign out of box        ->      Intermediate Operation      -> Put sign in pile
>                                           (paint sign)
>                                      Paint sign -> Only do 2 signs 
> ```
>

&emsp;&emsp;
The foreperson still sees a source of taking signs out of the box and assigns a worker to do that on command. They 
still see an intermediate operation to paint and set up another worker with instructions to wait and then paint. Then 
they see an intermediate step that we need only two signs. They set up a worker to count the signs that go by and notify 
the foreperson when the worker has seen two. Finally, they set up a worker for the terminal operation to put the signs 
in a pile.

&emsp;&emsp;
This time, suppose that there are 10 signs in the box. We start like last time. The first sign makes its way down the 
pipeline. The second sign also makes its way down the pipeline. When the worker in charge of counting sees the second 
sign, they tell the foreperson. The foreperson lets the terminal operation worker finish their task and then yells, 
“Stop the line.” It doesn’t matter that there are eight more signs in the box. We don’t need them, so it would be 
unnecessary work to paint them. And we all want to avoid unnecessary work!

&emsp;&emsp;
Similarly, the foreperson would have stopped the line after the first sign if the terminal operation was to find the 
first sign that gets created.

&emsp;&emsp;
In the following sections, we cover the three parts of the pipeline. We also discuss special types of streams for 
primitives and how to print a stream

## II. Creating Stream Sources
In Java, the streams we have been talking about are represented by the ```java Stream<T> ``` interface, defined in 
the ```java java.util.stream ``` package.
### 1. Creating Finite Streams
For simplicity, we start with finite streams. There are a few ways to create them.
```java
11: Stream<String> empty = Stream.empty();              // count = 0
12: Stream<Integer> singleElement = Stream.of(1);       // count = 1
13: Stream<Integer> fromArray = Stream.of(1, 2, 3);     // count = 3
```

&emsp;&emsp;
Java also provides a convenient way of converting a Collection to a stream.
```java
14: var list = List.of("a", "b", "c");
15: Stream<String> = fromList = list.stream();
```
> __Creating a Parallel Stream__
> It is just as easy to create a parallel stream from the list.
> ```java
> 24: var list = List.of("a", "b", "c");
> 25: Stream<String> fromListParallel = list.parallelStream();
> ```
> This is a great feature because you can write code that uses concurrency before even learning what a thread is. Using 
> parallel streams is like setting up multiple tables of workers who can do the same task. Painting would be a lot 
> faster if we could have five painters painting signs instead of just one. Just keep in mind some tasks cannot be done 
> in parallel, such as putting the signs away in the order that they were created in the stream. Also be aware that 
> there is a cost in coordinating the work, so for smaller streams, it might be faster to do it sequentially. You learn 
> much more about running tasks concurrently in Chapter 13, “Concurrency.”
> 

### 2. Creating Infinite Streams